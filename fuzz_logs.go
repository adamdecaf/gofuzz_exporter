// Copyright 2020 Adam Shannon
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"path"
	"time"

	"github.com/moov-io/infra/pkg/gofuzz"

	kitprom "github.com/go-kit/kit/metrics/prometheus"
	stdprom "github.com/prometheus/client_golang/prometheus"
)

type Config struct {
	Apps     []string
	Interval time.Duration

	Loki LokiConfig
}

type LokiConfig struct {
	Address string
}

func grabFuzzLogs(ctx context.Context, cfg *Config) {
	tick := time.NewTicker(cfg.Interval)
	defer tick.Stop()

	log.Printf("using %s for Loki address", cfg.Loki.Address)

	for {
		select {
		case <-tick.C:
			log.Print("refreshing fuzz logs")
			if err := scrapeAllAppLogs(cfg.Apps, cfg.Loki); err != nil {
				log.Printf("error scraping logs: %v", err)
			}

		case <-ctx.Done():
			log.Print("shutting down fuzz scraping")
			return
		}
	}
}

func scrapeAllAppLogs(apps []string, lokiConfig LokiConfig) error {
	for i := range apps {
		line, err := scrapeAppLogs(apps[i], lokiConfig)
		if err != nil {
			return fmt.Errorf("scrape app=%s error=%v", apps[i], err)
		}
		recordFuzzStats(apps[i], line)
	}
	return nil
}

// Via https://mholt.github.io/json-to-go/
type AutoGenerated struct {
	Status string `json:"status"`
	Data   struct {
		ResultType string `json:"resultType"`
		Result     []struct {
			Stream struct {
				App             string `json:"app"`
				Filename        string `json:"filename"`
				Instance        string `json:"instance"`
				Job             string `json:"job"`
				Namespace       string `json:"namespace"`
				PodTemplateHash string `json:"pod_template_hash"`
				Stream          string `json:"stream"`
			} `json:"stream"`
			Values [][]string `json:"values"` // grab this, parse each line until something passes
		} `json:"result"`
	} `json:"data"`
}

var (
	httpClient = &http.Client{
		Timeout: 10 * time.Second,
	}
)

func scrapeAppLogs(app string, lokiConfig LokiConfig) (*gofuzz.Line, error) {
	addr, err := url.Parse(lokiConfig.Address)
	if err != nil {
		return nil, fmt.Errorf("url parse: %v", err)
	}
	u, err := url.Parse(fmt.Sprintf("%s://%s%s%s", addr.Scheme, addr.Host, path.Join(addr.Path, "loki", "api", "v1", "query"), fmt.Sprintf(`?query={app="%s"}&limit=1`, app)))
	if err != nil {
		return nil, fmt.Errorf("url prep: %v", err)
	}

	resp, err := httpClient.Get(u.String())
	if err != nil {
		return nil, fmt.Errorf("http get: %v", err)
	}

	var wrapper AutoGenerated
	if err := json.NewDecoder(resp.Body).Decode(&wrapper); err != nil {
		return nil, fmt.Errorf("json decode: %v", err)
	}

	for i := range wrapper.Data.Result {
		for j := range wrapper.Data.Result[i].Values {
			for k := range wrapper.Data.Result[i].Values[j] {
				if line, err := gofuzz.ParseLine(wrapper.Data.Result[i].Values[j][k]); line != nil && err == nil {
					return line, nil
				}
			}
		}
	}

	return nil, nil
}

var (
	workerCount = kitprom.NewGaugeFrom(stdprom.GaugeOpts{
		Name: "gofuzz_workers",
		Help: "Count of workers for a go-fuzz process",
	}, []string{"app"})

	corpusCount = kitprom.NewGaugeFrom(stdprom.GaugeOpts{
		Name: "gofuzz_corpus",
		Help: "Count of corpus for a go-fuzz process",
	}, []string{"app"})

	crashersCount = kitprom.NewGaugeFrom(stdprom.GaugeOpts{
		Name: "gofuzz_crashers",
		Help: "Count of crashers for a go-fuzz process",
	}, []string{"app"})

	executions = kitprom.NewGaugeFrom(stdprom.GaugeOpts{
		Name: "gofuzz_executions",
		Help: "Count of executions for a go-fuzz process",
	}, []string{"app"})
)

func recordFuzzStats(app string, stats *gofuzz.Line) {
	workerCount.With("app", app).Set(float64(stats.WorkerCount))
	corpusCount.With("app", app).Set(float64(stats.CorpusCount))
	crashersCount.With("app", app).Set(float64(stats.CrashersCount))
	executions.With("app", app).Set(float64(stats.Executions))
}
